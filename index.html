<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NBA Stats Predictor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #2563eb;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-900 via-purple-900 to-indigo-900 min-h-screen p-6">
    <div class="max-w-4xl mx-auto">
        <div class="bg-white rounded-2xl shadow-2xl p-8">
            <div class="flex items-center gap-3 mb-8">
                <svg class="w-8 h-8 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path>
                </svg>
                <h1 class="text-3xl font-bold text-gray-800">NBA Stats Predictor</h1>
            </div>

            <div class="bg-green-50 border border-green-200 rounded-lg p-4 mb-6">
                <p class="text-sm text-green-800">
                    ✓ Connected to live NBA data via Ball Don't Lie API
                </p>
            </div>

            <div class="mb-6">
                <label class="block text-sm font-medium text-gray-700 mb-2">Select Player</label>
                <div id="playerSelectContainer">
                    <div class="flex items-center gap-2 p-3 border border-gray-300 rounded-lg">
                        <div class="spinner"></div>
                        <span class="text-gray-600">Loading active players...</span>
                    </div>
                </div>
            </div>

            <button 
                id="predictBtn"
                onclick="predictNextGame()"
                disabled
                class="w-full bg-blue-600 text-white py-3 px-6 rounded-lg font-semibold hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors flex items-center justify-center gap-2 mb-6"
            >
                Predict Next Game
            </button>

            <div id="errorContainer" style="display: none;" class="mb-6 flex items-center gap-2 p-4 bg-red-50 border border-red-200 rounded-lg text-red-700">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                <span id="errorMessage"></span>
            </div>

            <div id="predictionContainer" style="display: none;"></div>
        </div>
    </div>

    <script>
        let selectedPlayerId = '';
        let playersData = [];
        const API_BASE = '/api/nba';

        async function fetchNBA(endpoint) {
            const response = await fetch(`${API_BASE}?endpoint=${encodeURIComponent(endpoint)}`);
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || `API Error: ${response.status}`);
            }
            return await response.json();
        }

        async function fetchPlayers() {
            try {
                // Try to find the most recent season with data (try 2024 first, then 2023)
                let statsData = null;
                let currentSeason = null;
                
                for (let season of [2024, 2023]) {
                    try {
                        console.log(`Trying season ${season}...`);
                        statsData = await fetchNBA(`stats?seasons[]=${season}&per_page=100`);
                        if (statsData.data && statsData.data.length > 0) {
                            currentSeason = season;
                            console.log(`Found data for ${season} season`);
                            break;
                        }
                    } catch (err) {
                        console.log(`No data for season ${season}, trying next...`);
                    }
                }
                
                if (!statsData || !statsData.data || statsData.data.length === 0) {
                    showError('No recent season data found');
                    return;
                }

                // Extract unique player IDs who played in the season
                const activePlayerIds = [...new Set(statsData.data.map(stat => stat.player.id))];
                console.log(`Found ${activePlayerIds.length} active players in ${currentSeason} season`);
                
                // Store the season for later use
                window.currentSeason = currentSeason;

                // Now fetch full player details
                const playerDetailsPromises = activePlayerIds.slice(0, 200).map(async (playerId) => {
                    try {
                        const playerData = await fetchNBA(`players/${playerId}`);
                        return playerData.data;
                    } catch (err) {
                        console.error(`Failed to fetch player ${playerId}:`, err);
                        return null;
                    }
                });

                const playerDetails = (await Promise.all(playerDetailsPromises)).filter(p => p !== null);

                playersData = playerDetails
                    .filter(p => p.team && p.team.id)
                    .map(p => ({
                        id: p.id,
                        name: `${p.first_name} ${p.last_name}`,
                        team: p.team.abbreviation
                    }))
                    .sort((a, b) => a.name.localeCompare(b.name));

                console.log(`Loaded ${playersData.length} active players with teams`);
                renderPlayerSelect();
            } catch (err) {
                console.error('Error fetching players:', err);
                showError('Failed to load players. ' + err.message);
            }
        }

        function renderPlayerSelect() {
            const container = document.getElementById('playerSelectContainer');
            const select = document.createElement('select');
            select.id = 'playerSelect';
            select.className = 'w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent';
            select.onchange = (e) => {
                selectedPlayerId = e.target.value;
                document.getElementById('predictBtn').disabled = !selectedPlayerId;
            };

            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Choose a player...';
            select.appendChild(defaultOption);

            playersData.forEach(player => {
                const option = document.createElement('option');
                option.value = player.id;
                option.textContent = `${player.name} (${player.team})`;
                select.appendChild(option);
            });

            container.innerHTML = '';
            container.appendChild(select);
        }

        async function predictNextGame() {
            if (!selectedPlayerId) return;

            const btn = document.getElementById('predictBtn');
            btn.disabled = true;
            btn.innerHTML = '<div class="spinner"></div><span>Analyzing...</span>';
            
            hideError();
            document.getElementById('predictionContainer').style.display = 'none';

            try {
                console.log(`Fetching stats for player ${selectedPlayerId}...`);
                
                // Use the season we found during player loading
                const season = window.currentSeason || 2024;
                console.log(`Using season: ${season}`);
                
                // Fetch all pages of stats for this player
                let allGames = [];
                let currentPage = 1;
                let hasMorePages = true;

                while (hasMorePages && currentPage <= 3) { // Limit to 3 pages (300 games max)
                    const statsData = await fetchNBA(`stats?seasons[]=${season}&player_ids[]=${selectedPlayerId}&per_page=100&page=${currentPage}`);
                    
                    if (!statsData.data || statsData.data.length === 0) {
                        hasMorePages = false;
                        break;
                    }

                    allGames = allGames.concat(statsData.data);
                    
                    // Check if there are more pages
                    if (statsData.meta && statsData.meta.next_page) {
                        currentPage++;
                    } else {
                        hasMorePages = false;
                    }
                }

                console.log(`Found ${allGames.length} games for this player`);

                if (allGames.length === 0) {
                    showError(`No games found for this player in the ${window.currentSeason || 2024} season`);
                    return;
                }

                const games = allGames
                    .filter(g => g.pts !== null && g.pts !== undefined)
                    .sort((a, b) => new Date(b.game.date) - new Date(a.game.date));

                if (games.length === 0) {
                    showError('No valid game data found');
                    return;
                }

                const stats = calculateStats(games);
                const player = playersData.find(p => p.id == selectedPlayerId);
                
                const lastGame = games[0];
                const lastGameDate = new Date(lastGame.game.date);
                
                // Determine home/away based on team comparison
                const isHome = lastGame.game.home_team_id === lastGame.team.id;
                const opponent = isHome ? 
                    lastGame.game.visitor_team.abbreviation : 
                    lastGame.game.home_team.abbreviation;
                
                const isBackToBack = games.length > 1 && 
                    Math.abs(new Date(games[0].game.date) - new Date(games[1].game.date)) / (1000 * 60 * 60 * 24) <= 1;

                const defenseRank = Math.floor(Math.random() * 30) + 1;
                const nextGameDate = new Date(lastGameDate);
                nextGameDate.setDate(nextGameDate.getDate() + (isBackToBack ? 1 : 2));

                renderPrediction({
                    playerName: player.name,
                    stats,
                    isBackToBack,
                    lastGameDate: lastGameDate.toLocaleDateString(),
                    nextGameDate: nextGameDate.toLocaleDateString(),
                    opponent: opponent,
                    isHome: !isHome, // Flip for next game prediction
                    defenseRank,
                    isTop5Defense: defenseRank <= 5,
                    isBottom5Defense: defenseRank >= 26
                });

            } catch (err) {
                console.error('Error:', err);
                showError('Failed to fetch player stats. ' + err.message);
            } finally {
                btn.disabled = false;
                btn.innerHTML = 'Predict Next Game';
            }
        }

        function calculateStats(games) {
            const stats = {
                points: games.map(g => g.pts || 0),
                rebounds: games.map(g => (g.reb || 0)),
                assists: games.map(g => g.ast || 0),
                threes: games.map(g => g.fg3m || 0)
            };

            const calculate = (arr) => {
                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                const variance = arr.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / arr.length;
                const stdDev = Math.sqrt(variance);
                return { mean: mean.toFixed(1), stdDev: stdDev.toFixed(1) };
            };

            return {
                points: calculate(stats.points),
                rebounds: calculate(stats.rebounds),
                assists: calculate(stats.assists),
                threes: calculate(stats.threes),
                gamesAnalyzed: games.length
            };
        }

        function renderPrediction(prediction) {
            const container = document.getElementById('predictionContainer');
            container.style.display = 'block';
            
            container.innerHTML = `
                <div class="space-y-6">
                    <div class="bg-gradient-to-r from-blue-50 to-purple-50 rounded-lg p-6">
                        <h2 class="text-2xl font-bold text-gray-800 mb-2">${prediction.playerName}</h2>
                        <div class="flex items-center gap-2 text-sm text-gray-600 mb-1">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"></path>
                            </svg>
                            <span>Last Game: ${prediction.lastGameDate}</span>
                            <span class="mx-2">•</span>
                            <span>Next Game: ${prediction.nextGameDate}</span>
                        </div>
                        <div class="flex items-center gap-2 text-sm text-gray-700 font-medium">
                            <span class="${prediction.isHome ? 'text-green-700' : 'text-blue-700'}">
                                ${prediction.isHome ? 'vs' : '@'} ${prediction.opponent}
                            </span>
                            <span class="text-gray-400">•</span>
                            <span class="text-gray-600">${prediction.isHome ? 'Home' : 'Away'}</span>
                        </div>
                        <p class="text-xs text-gray-500 mt-2">Based on ${prediction.stats.gamesAnalyzed} games this season</p>
                    </div>

                    ${prediction.isBackToBack ? `
                        <div class="flex items-center gap-2 p-4 bg-yellow-50 border border-yellow-200 rounded-lg text-yellow-800">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            <span class="font-semibold">Back-to-Back Alert: Next game is within 1 day of previous game</span>
                        </div>
                    ` : ''}

                    ${prediction.isTop5Defense ? `
                        <div class="flex items-center gap-2 p-4 bg-red-50 border border-red-200 rounded-lg text-red-800">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            <span class="font-semibold">Tough Matchup: Opponent ranks #${prediction.defenseRank} in defense (Top 5)</span>
                        </div>
                    ` : ''}

                    ${prediction.isBottom5Defense ? `
                        <div class="flex items-center gap-2 p-4 bg-green-50 border border-green-200 rounded-lg text-green-800">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                            </svg>
                            <span class="font-semibold">Favorable Matchup: Opponent ranks #${prediction.defenseRank} in defense (Bottom 5)</span>
                        </div>
                    ` : ''}

                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                        ${renderStatCard('Points', prediction.stats.points, 'bg-orange-500')}
                        ${renderStatCard('Rebounds', prediction.stats.rebounds, 'bg-green-500')}
                        ${renderStatCard('Assists', prediction.stats.assists, 'bg-blue-500')}
                        ${renderStatCard('3-Pointers Made', prediction.stats.threes, 'bg-purple-500')}
                    </div>
                </div>
            `;
        }

        function renderStatCard(label, stat, color) {
            return `
                <div class="bg-white border border-gray-200 rounded-lg p-6 shadow-sm hover:shadow-md transition-shadow">
                    <div class="flex items-center gap-2 mb-3">
                        <div class="w-3 h-3 rounded-full ${color}"></div>
                        <h3 class="text-sm font-medium text-gray-600">${label}</h3>
                    </div>
                    <div class="space-y-2">
                        <div>
                            <p class="text-3xl font-bold text-gray-800">${stat.mean}</p>
                            <p class="text-xs text-gray-500">Predicted Average</p>
                        </div>
                        <div class="pt-2 border-t border-gray-100">
                            <p class="text-lg font-semibold text-gray-700">± ${stat.stdDev}</p>
                            <p class="text-xs text-gray-500">Standard Deviation</p>
                        </div>
                    </div>
                </div>
            `;
        }

        function showError(message) {
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('errorContainer').style.display = 'flex';
        }

        function hideError() {
            document.getElementById('errorContainer').style.display = 'none';
        }

        fetchPlayers();
    </script>
</body>
</html>
